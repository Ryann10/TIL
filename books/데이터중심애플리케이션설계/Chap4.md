# 부호화와 발전


- 부호화
- 복호화


### 스리프트와 프로토콜 버퍼

- 스리프트
  - 바이너리프로토콜
  - 컴팩트프로토콜

- 프로토콜 버퍼

- 아브로
  - 동적 생성 스키마
      - 스키마에 태그 번호가 포함돼 있지 않다

## 데이터플로 모드

- 프로세스 간 데이터를 전달하는 가장 보편적인 방법
  - 데이터베이스를 통해
  - 서비스 호출을 통해
  - 비동기 메시지 전달을 통해

### 데이터베이스를 통한 데이터플로

데이터 베이스에 기록하는 프로세스는 데이터를 부호화하고, 데이터베이스에서 읽는 프로세스는 데이터를 복호화한다

#### 데이터 베이스를 접근하는 단일 프로세스가 있다고 하자

- 읽기는 단순히 동일 프로세스의 최신 버전
  - DB에 뭔가를 저장하는 일을 미래의 자신에게 메시지를 보내는 일처럼 생각 할 수 있다.
  - 하위 호환성이 필요한 이유: 그렇지 않으면 이전에 기록한 내용을 미래의 자신이 복호화할 수 없다.
  - 상위 호환성이 필요한 이유: DB 내 값이 **새로운** ㅇ버전의 코드로 기록된 다음 현재 수행 중인 **예전 버전**의 코드로 그 값을 읽을 가능성이 있다.
  - 문제 상황
    - 레코드 스키마에 필드를 추가하고 새로운 코드는 새로운 필드를 위한 값을 DB에 기록할 때
      - 예전 버전의 코드가 레코드를 읽고 갱신한 후 갱신한 값을 다시 기록할 때: 예전 코드가 해석할 수 없더라도 새로운 필드를 그대로 유지하는 것
      - 애플리케이션 레벨: DB 값을 모델 객체로 복호화하고 나중에 이 모델 객체를 다시 재부호화(reencode)할 때 유의해야 함

#### 다양한 시점에 기록된 다양한 값

**데이터가 코드보다 더 오래 산다(Data outlives code)**: 애플리케이션은 몇 분 내에 예전 버전을 새 버전으로 완전히 대체할 수 있지만, 5년된 데이터는 그 이후로 명시적으로 다시 기록하지 않는 한 원래의 부호화 상태 그대로 있는 것

#### 보관 저장소

데이터 덤프는 보통 최신 스키마를 사용해 부호화 한다. 데이터의 복사본을 일관되게 부호화하는 편이 낫기 때문

### 서비스를 통한 데이터플로: REST와 RPC

**클라이언트**와 **서버** 두 역할로 네트워크 통신 배치. 서버는 네트워크를 통해 API를 공개하고 클라이언트는 이 API로 요청을 만들어 서버에 연결할 수 있다. 서버가 공개한 API를 **서비스**라고 한다.

**서비스 지향 설계(Service-Oriented Architecture, SOA)**: 하나의 서비스가 다른 서비스의 일부 기능이나 데이터가 필요하다면 해당 서비스에 요청을 보내는 방식의 설계. **마이크로서비스 설계(Microsoervies architecture)**란 이름으로 재탄생함.

#### 웹 서비스

서비스와 통신하기 위한 기본 프로토콜로 HTTP를 상용할 때 이를 **웹 서비스**라고 한다.
> 웹뿐만 아니라 다른 상황에서도 사용 될 수 있기 때문에 사실은 잘못된 표현

- 사용자 디바이스에서 실행하며 HTTP를 통해 서비스에 요청하는 클라이언트 애플리케이션. 보통 Public Internet을 통해 전달된다.
- 서비스 지향/마이크로 서비스 아키텍처의 일부로서 대게 같은 데이터센터에 위치한 같은 조직의 다른 서비스에 요청하는 서비스. (이런 종류의 사용 사례를 지원하는 소프트웨어를 **미들웨어**라고 함)
- 보통 인터넷을 통해 다른 조직의 서비스에 요청하는 서비스. 다른 조직의 백엔드 시스템 간 데이터 교환을 위해 사용. 공개 API나 사용자 데이터의 공유 접근을 위한 OAuth가 포함

#### REST vs SOAP

- REST
  - HTTP의 원칙을 토대로 한 설계 철학
  - 간단한 데이터 타입을 강조
  - URL을 사용해 리소스를 식별
  - 캐시 제어, 인증, 컨텐츠 유형 협상에 HTTP 기능을 사용
- SOAP
  - 네트워크 API 요청을 위한 XML 기반 프로토콜
  - HTTP 상에서 대부분 사용되지만 HTTP 기능을 사용하지는 않음
  - WSDL 이라는 XML 기반 언어를 사용해 기술
    - WSDL은 사람이 읽을 수 있게 설계하지 않았음
    - SOAP 메시지를 수동으로 구성하기에는 너무 복잡함

#### 원격 프로시저 호출(RPC) 문제
