# 구조적 프로그래밍

## 증명

데이크스트라가 초기에 인식한 문제는 프로그래밍은 어렵고, 프로그래머는 프로그래밍을 잘하지 못한다는 사실이었다. 모든 프로그램은 설령 단순할지라도 인간의 두뇌로 감당하기에는 너무 많은 세부사항을 담고 있었다. 아주 작은 세부사항이라도 간과하면 프로그램이 동작하는 것처럼 보이더라도 결국엔 예상 외의 방식으로 실패하곤 했다.

데이크스트라는 증명proof라는 수학적인 원리를 적용하여 이 문제를 해결하고자 했다. 그의 비전은 공리, 정리, 따름정리, 보조정리로 구성되는 유클리드 계층구조를 만드는 것이었다. 프로그래머는 입증된 구조를 이요하고, 이들 ㄱ조를 코드와 결합시키며, 그래서 코드가 올바르다는 사실을 스스로 증명하게 되는 방식이었다.

goto 문장을 사용하더라도 모듈을 분해할 때 문제가 되지않는 경우는 if/then/else 와 do/while과 같은 분기와 반복이라는 단순한 제어 구조에 해당한다는 사실을 발견했다. 모듈이 이러한 종류의 제어 구조만을 사용한다면 증명 가능한 단위까지 모듈을 재귀적으로 세분화하는 것이 가능해 보였다.

이러한 벶어 구조는 순하 실행 sequential execution과 결합 했을 때 특별하다. 프로그램은 순차sequence, 분기selection, 반복iteration이라는 세 가지 구조만으로 표현할 수 있다. 즉, 모듈을 증명 가능하게 하는 바로 그 제어 구조가 모든 프로그램을 만들 수 있는 젣어 구조의 최소 집합과 동일하다는 사실이었다. 구조적 프로그래밍은 이렇게 탄생했다.

데이크스트라는 단순한 열거법을 이용해 순차 구문sequential statement이 올바름을 입증할 수 있다는 사실을 보여주었다. 이 기법에서는 각 순차 구문의 입력을 순차 구문의 출력까지 수학적으로 추적한다.

분기selection의 경우 데이크스트라는 열거법을 재적용하는 방식으로 처리했다. 먼저 분기를 통한 각 경로를 열거했다. 결과적으로 두 경로가 수학적으로 적절한 결과를 만들어낸다면, 증명은 신뢰할 수 있게 된다.

반복iteration은 조금 다르다. 반복이 올바름을 증명하기 위해 데이크스트라는 귀납법induction을 사용했다. 열거법에 따라 1의 경우가 올바름을 증명했다. 그리고 N의 경우가 올바르다고 가정할 때 N + 1의 경우도 올바름을 증명하며, 이 경우에도 열거법을 사용했다. 또한 반복의 시작 조건과 종료 조건도 열거법을 통해 증명했다.

## 기능적 분해

구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있게 되었고, 이는 결국 모듈을 기능적으로 분해할 수 있음을 뜻했다. 즉, 거대한 문제 기술서를 받더라도 문제를 고수준의 기능들로 분해할 수 있다. 그리고 이들 각 기능은 다시 저수준의 함수들로 분해할 수 있고, 이러한 분해 과정을 끝없이 반복할 수 있다. 게다가 이렇게 분해한 기능들은 구조적 프로그래밍의 제한된 제어 구조를 이용하여 표현할 수 있다.

이를 토대로 구조적 분석structured analysis이나 구조적 설계structured design와 같은 기법을 개산하여 대규모 시스템을 모듈과 컴포넌트로 나눌 수 있고, 더 나아가 모듈과 컴포넌트는 입증할 수 있는 아주 작은 기능들로 세분화할 수 있었다.
