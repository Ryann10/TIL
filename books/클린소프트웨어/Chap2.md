# Chap2 익스트림 프로그래밍 소개

## 익스트림 프로그래밍 실천방법

애자일 방법 중에서 단순하면서도 서로 의존적인 실천 방법의 집합으로 구성되어 있다. 이 실천방법은 각 부분보다 큰 전체를 구성하기 위해 함께 작동한다.

### 고객 팀 구성원

XP 팀의 고객은 기능 요소를 정의하고 우선순위를 매기는 개인 또는 그룹이다. 경우에 따라서 고객은 같은 회사에서 일하는 팀원일 수도 있다.

### 사용자 스토리

프로젝트 일정 계획을 세우기 위해서는 요구사항에 대해 알아야 하지만, 아주 자세히 알 필요는 없다. 요구사항을 추정할 수 있을 만큼의 정보만 알면 된다.

요구사항의 구체적인 세부 내용은 시간이 지남에 따라 바뀌기 쉽다. 특히 고객이 시스템이 동작하는 것을 보면서부터는 더욱 그렇다.

XP를 사용할 때는 고객과 대화함으로써 요구사항의 세부 내용에 대한 감을 잡지만, 세부 사항을 기록하지는 않는다. 그보다도 고객은 같이 합의해서 정한 색인 카드에 몇 개의 단어를 적어 그 대화 내용을 기억한다. 개발자는 고객이 색인 카드에 단어를 적을 때, 고객과의 대화를 바탕으로 추정한 내용을 카드에 기록한다.

사용자 스토리란 현재 진행 중인 요구사항에 관한 대화의 연상 기호다. 고객이 우선순위와 추정 비용에 근거해 요구사항의 구현 일정을 수립하게 해주는 계획 툴이다.

### 짧은 반복

XP 프로젝트는 개발 중인 소프트웨어를 2주마다 공개한다. 2주마다 요구 사항을 충족하는 SW를 만들고, 반복(iteration) 끝마다 이해 당사자의 피드백을 받기 위해 시스템을 시연한다.

#### 반복 계획

반복은 보통 2주 단위로 진행된다. 이것은 최종 제품에 반영될 수도, 그렇지 않을 수도 있는 마이너 공개(minor delivery)임을 뜻한다. 반복 계획(iteration plan)은 개발자가 세운 예산에 따라 고객이 선택한 사용자 스토리의 집합니다.

개발자는 이전 반복에서 얼마나 완성할 수 있었는가를 측정하여 각 반복의 예산을 세운다. 고객은 전체 견적이 그 예산을 넘지 않는 한도로 각 반복의 스토리를 선택할 수 있다.

일단 반복이 시작되면, 고객은 그 반복 동안에는 스토리 저의나 우선순위를 바꾸지 ㅇ낳는다고 동의한다. 개발자는 스토리를 자유롭게 태스크에 나눠 넣고 기술적, 업무적으로 가장 합리적인 순서로 그 태스크를 수행해나간다.

### 릴리즈 계획

XP 팀은 종종 다음 약 6번의 반복 일정을 정밀하게 표현하는 릴리즈 계획(release plan)을 만든다. 릴리즈는 대개 3개월 동안을 의미하며, 보통 최종 제품에 포함되는 메이저 공개(major delivery)를 뜻한다. 릴리즈 계획은 개발자가 제시한 예산에 맞춰 고객이 선택한, 우선순위가 정해진 '사용자 스토리'의 묶음으로 구성된다.

### 인수 테스트

사용자 스토리의 세부 사항은 고객이 명시한 인수 테스트(acceptance test)의 형태로 기록된다. 인수 테스트는 자동적으로, 또 반복적으로 실행될 수 있는 스크립트 언어의 한 종류로 작성된다. 이 테스트는 시스템이 고객이 명시한 대로 동작하는지 여부를 검증한다.

많은 고객이 인수 테스트 툴 개발에 QA 부서를 참여시키고, 직접 인수 테스트를 만든다.

### 짝 프로그래밍

모든 운영 코드(production code)는 같은 워크스테이션으로 일하는 프로그래머 짝들에 의해 작성된다. 한 팀원은 키보드를 잡고 코드를 입력한다. 다른 한 팀원은 입력되는 코드를 보면서 에러와 개선점을 찾는다. 이렇게 두 프로그래머는 아주 긴밀히 상호작용하게 된다.

역할은 자주 바뀔 수 있고, 입력하는 사람이 지치거나 지겨워하면 다른 팀원이 키보드를 대신 잡고 입력을 시작한다.

이런 방식은 팀 내부에서 지식이 더 빨리 확산되게 한다. 전문 분담 방식이 유지되며, 보통 어떤 전문성을 요구하는 태스크는 적절한 전문가에게 맡긴다.

### 테스트 주도 개발

모든 운영 코드는 실패하는 단위 테스트를 통과하기 위해 작성된다. 우선, 우리는 프로그램에 테스트하는 기능이 구현되어 있지 않기 때문에 당연히 실패하는 단위 테스트 프로그램을 작성한다. 그런 다음, 그 테스트를 통과하는 코드를 작성한다.

테스트 케이스의 완성된 본문은 코드와 함께 발전한다. 이 테스트는 프로그래머로 하여금 프로그램이 잘 동작하는지 점검할 수 있게 해준다. 이런 방식은 리팩토링을 굉장히 용이하게 만든다

테스트 케이스를 통과하기 위한 코드를 작성한다면, 그 코드는 당연히 테스트 가능한 것이어야 한다. 그리고 코드를 모듈별로 분리하여 각각 독립적으로 테스트될 수 있게 해야 한다는 필요성도 강력히 대두되고 있다. 따라서 이런 방식으로 작성되는 코드 구조는 상호 간섭이 아주 적은데, 객체 지향 설계 원칙은 이런 비간섭화를 구현하는 데 큰 역할을 한다.

### 공동 소유권

짝은 어떤 모듈이라도 점검하고 개선할 권리를 갖는다. 프로그래머는 하나의 개별적인 모듈이나 기술에 대해 개인적으로 책임을 지지 안흔ㄴ다.

### 지속적인 통합


### 지속 가능한 속도

XP 규칙은 팀이 초과 근무를 하지 않도록 해야 한다는 것이다. 이 규칙의 유일한 예외는 릴리즈의 마지막 주다. 릴리즈라는 골에서 아주 가까운 거리에 있고 종점을 향해 전력질주를 할 수 있다면, 초과 근무도 무방하다.

### 열린 작업 공간

### 계획 세우기 게임

### 단순한 설계

XP 팀은 그들의 설계를 가능한 한 단순하고 표현적으로 만든다.

XP 팀은 기반구조(infrastructure)를 이용해 시작하지 않을 것임을 의미한다. 팀의 첫 번째 행동은 가능한 한 가장 단순한 방식으로 동작하는 스토리의 첫 묶음을 얻어내는 것이 될 것이다. 팀은 스토리가 진행되어 그것을 강요할 때만 기반구조를 추가할 것이다.

- 어떻게든 동작하는 가장 단순한 것을 생각한다.
  - 실제로 구현할 수 있을 정도로 최대한 단순한 솔루션을 선택한다.
- 필요하지 않을 것이라는 가정에서 시작한다.
  - XP 팀은 확실히 필요해지기 전에 기반구조를 추가하고 싶은 유혹에 저항하지 않을 떄 무슨 일이 일어날 것인지 심각하게 고려한다. 즉, 기반구조가 필요하지 않을 것이라는 가정하에 프로젝트를 시작한다. 팀은 지금 기반구조를 추가하는 것이 기다리는 것보다 비용 면에서 효과적이라는 확실한 증거가 있을 때, 또는 적어도 아주 강한 근거가 있을 때 비로소 기반구조를 추가한다.
- 코드를 중복해서 쓰지 않는다.
  - XP를 수행하는 사람은 코드 중복을 허용하지 않으면, 중복 코드가 발견될 때마다 이를 제거한다.
  - 중복성(redundancy)를 제거하는 최선의 방법은 추상화(abstraction)다. 두 코드가 비슷한 경우 그것을 통합할 수 있는 어떤 추상형이 존재할 것이다. 따라서 주옵ㄱ성을 제거하기 위해 팀은 많은 추상형을 만들고, 그 결과 결합도(coupling)도 낮아진다.

### 리팩토링

코드는 부패하기 쉽다.

XP 팀은 이런 퇴화를 잦은 리팩토링으로 반전시킨다.

각각의 작은 변환이 끝나고 나면, 아무 문제도 없음을 확인하기 위해 단위 테스트를 실시한다. 그리고 각 변환 끝에 테스트를 실시하면서 다음 변환을 계속 수행한다. 이런 식으로 시스템의 설계를 바꾸면서 동시에 시스템이 제대로 도앚ㄱ하게 할 수 있다.

### 메타포

메타포는 전체 시스템을 하나로 묶는 큰 그림이다. 이것은 모든 개별적인 모듈의 위치화 형태를 명백하게 만드는 시스템의 비전(vision)이다. 모듈의 형태가 메타포와 일치하지 않는다면, 그 모듈이 잘못되었음을 알 수 있다.
