# 하드웨어와 운영체제

90년대 이후 애플리케이션 개발은 intel x86/64 아키텍처 위주

## 메모리

트랜지스터 갯수 증가 -> 클록 속도를 높이는데 사용 -> 클록 속도가 즈가하면 초당 더 많은 명령어가 처리 가능 -> 시간이 갈수록 프로세서 코어의 데이터 수요를 메인 메모리가 감당하지 못하기 (프로세서와 메모리간 성능 차이 격차 심화)

### 메모리 캐시

위의 문제로 CPU 캐시가 고안.

속도: 레지스터 > CPU 캐시 > 메인 메모리

액세스 빈도가 높은 캐시일수록 프로세서 코어와 더 가까이 위치 L1~L3

- 각 실행 코어에 전용 프라이빗 캐시 L1, L2
- 일부 또는 전체 코어가 공유하는 L3

메인 메모리는 노스브리지Northbridige 컴포넌트를 거쳐 액세스

#### 캐시 일관성 프로토콜Cache consistency protocol

CPU 캐시가 생기면서 프로세서 처리율은 개선됐지만 메모리에 있는 데이터를 캐시로 어떻게 가져오고, 캐시된 데이터를 어떻게 메모리에 다시 쓸지 결정해야 하는 문제를 **캐시 일관성 프로토콜**로 해결

멀티 프로세서가 동시에 공유 상태에 있을 수 있다는 것. 어느 한 프로세서가 베타나 수정 상태로 바뀌면 다른 프로세서는 모두 강제로 무효 상태가 됨

이 프로토콜에서는 프로세서가 상태를 바구겠다는 의사를 브로드캐스팅함(공유 메모리 버스를 통해 전기 신호를 전송)

프로토콜을 이용하여 개선하는 과정

1. Write-through: 처음엔 매번 캐시 연산 결과를 메모리에 바로 기록 -> 메모리 대역폭을 너무 많이 소모해 비효율
2. Write-back: 캐시 블록을 교체해도 프로세서가 변경된dirty 캐시 블록만 메모리에 기록

##### 캐시 하드웨어 작동 원리를 나타낸 코드

```java
public class Caching {

    private final int ARR_SIZE = 2 * 1024 * 1024;
    private final int[] testData = new int[ARR_SIZE];

    private void run() {
        System.err.println("Start: " + System.currentTimeMillis());

        for (int i = 0; i < 15_000; i++) {
            touchEveryLine();
            touchEveryLine();
        }

        System.err.println("Warmup Finished: " + System.currentTimeMillis());
        System.err.println("Item Line");
        for (int i = 0; i < 100; i++) {
            long t0 = System.nanoTime();
            touchEveryLine();
            long t1 = System.nanoTime();
            touchEveryItem();
            long t2 = System.nanoTime();
            long elItem = t2 - t1;
            long elLine = t1 - t0;
            double diff = elItem - elLine;
            System.err.println(elItem + " " + elLine + " " + (100 * diff / elLine));
        }
    }

    private void touchEveryItem() {
        for (int i = 0; i < testData.length; i++) {
            testData[i]++;
        }
    }

    private void touchEveryLine() {
        for (int i = 0; i < testData.length; i += 16) {
            testData[i]++;
        }
    }

    public static void main(String[] args) {
        Caching c = new Caching();
        c.run();
    }
}
```

실행 결과

```bash
Start: 1586941100175
Warmup Finished: 1586941113416
Item Line
7279800 464700 1466.5590703679793
3952600 920900 329.2105548919535
879400 955500 -7.964416535845107
636900 624900 1.9203072491598656
517700 493100 4.988846075846684
490700 439100 11.751309496697791
525900 639400 -17.751016578041913
484400 441800 9.64237211407877
483800 421800 14.69890943575154
856200 601500 42.34413965087282
587200 759000 -22.635046113306984
592800 582200 1.8206801786327722
528900 569200 -7.08011243851019
504000 448100 12.474893996875698
496200 425100 16.725476358503883
484100 419900 15.289354608240057
481200 406500 18.376383763837637
473900 408900 15.896307165566153
470600 395200 19.07894736842105
464400 395400 17.450682852807283
463300 393300 17.79811848461734
462000 392600 17.677024961793173
464500 429600 8.123836126629422
615700 696600 -11.613551536032157
499400 536900 -6.984540882845968
484800 446300 8.626484427515125
491000 417100 17.71757372332774
536200 424800 26.2241054613936
488000 650500 -24.980784012298233
481600 431900 11.507293354943274
739500 563800 31.163533167789996
616500 663000 -7.013574660633484
502600 550900 -8.767471410419313
491500 439600 11.806187443130119
502500 463100 8.50788166702656
485700 431100 12.665274878218511
746100 707200 5.500565610859729
536200 704800 -23.921679909194097
495500 530000 -6.509433962264151
552100 584300 -5.510867704946089
494200 490600 0.7337953526294333
519500 429200 21.039142590866728
484100 427600 13.213283442469598
507900 452300 12.292726066769843
516900 515300 0.31049873859887445
521100 500900 4.032741066081054
745800 514100 45.06905271347987
503000 528100 -4.752887710660859
483000 443700 8.857336037863421
897100 1037300 -13.51585847874289
588000 670400 -12.291169451073985
548000 574500 -4.6127067014795475
533400 544500 -2.038567493112948
594600 590900 0.6261634794381452
500700 566000 -11.537102473498233
605600 627600 -3.5054174633524537
495500 537700 -7.848242514413242
553500 484000 14.359504132231406
628100 588500 6.728971962616822
513000 546400 -6.112737920937042
1080900 536800 101.35991058122205
543800 618200 -12.034940148819153
499700 458700 8.93830390233268
501100 432900 15.754215754215755
477500 416600 14.618338934229477
474500 405800 16.9295219319862
490100 401500 22.067247820672478
473200 401600 17.828685258964143
470600 421400 11.675367821547223
534300 397700 34.3474981141564
557000 506700 9.926978488257351
489100 425300 15.001175640724195
479100 412400 16.173617846750727
479900 405800 18.260226712666338
711900 411500 73.00121506682868
675900 846400 -20.14413988657845
612000 704700 -13.154533844189016
679500 626400 8.477011494252874
686000 663400 3.4066927946940004
775700 876600 -11.510381017567877
733300 782200 -6.251598056762976
3730700 867100 330.2502594856418
876700 1347500 -34.93877551020408
558600 725600 -23.015435501653805
544100 556100 -2.1578852724330155
518700 632200 -17.953179373615946
493800 458100 7.79305828421742
487700 432500 12.763005780346822
485200 424200 14.38000942951438
488300 422100 15.68348732527837
475500 430500 10.452961672473867
477000 426800 11.76194939081537
491000 432900 13.421113421113422
483000 460400 4.908774978279757
480000 458200 4.757747708424269
867500 904600 -4.101260225514039
521700 664200 -21.454381210478772
493600 449800 9.737661182747887
491400 429600 14.385474860335195
485300 419700 15.630212056230642
```

touchEveryItem() 메소드와 touchEveryLine() 메소드의 시간 경과에 따른 패턴이 16배가 아니라 비슷

## 최신 프로세서 특징

### 변환 색인 버퍼Translation Lookaside Buffer

가상 메모리 주소를 물리 메모리 주소로 매핑하는 페이지 테이블의 캐시 역할을 수행

TLB가 없으면 L1 캐시에 페이지 테이블이 있어도 가상 주소 룩업에 16사이클이 소요

### 분기 예측Branch prediction

프로세서가 조건 분기하는 기준값을 평가하느라 대기하는 현상을 방지

### 추측 실행Speculative execution

최신 프로세서는 다단계 명령 파이프라인을 이용해 CPU 1사이클도 여러 개별 단계로 나누어 실행

-> 조건문을 다 평가하기 전까지 분기 이후 다음 명령을 알 수 없는 문제 발생

-> 프로세서는 트랜지스터를 활용해 가장 발생 가능성이 큰 브랜치는 미리 결정하는 휴리스틱을 형성

| 이 기법은 2018년에 발생한 주요 보안 문제들의 원인이 됨

### 하드웨어 메모리 모델

JMM은 프로세서 타입별로 상이한 메모리 액세스 일관성을 고려해 명시적으로 약한 모델로 설계

- [ ] http://preshing.com/20120930/weak-vs-strong-memory-models/

## 운영체제

메모리 관리 유닛Memory Management Unit을 통한 가상 주소virtual addressing과 페이지 테이블은 한 프로세스가 소유한 메모리 영역을 다른 프로세스가 함부로 훼손하지 못하게 방지

### 프로세스 스케줄러

프로세스 스케줄러는 CPU 액세스를 통제. 실행 큐run queue를 이용

스케줄러는 인터럽트에 응답하고 CPU 코어 액세스를 관리. 자바 명세서에는 이론적으로 자바 스레드가 굳이 OS 스레드와 일치할 필요 없는 스레딩 모델green thread을 허용한다고 씌어 있지만, 실제로 이런 방식이 유용하지 않다는 사실이 밝혀져 주류 운영 환경에서는 배제됨.

OS는 CPU에서 코드가 실행되지 않는 시간을 유발함. 자신의 할당 시간을 다 쓴 프로세스는 실행 큐 맨 앞으로 갈 때까지 CPU로 복귀하지 않음. 이러한 지터jitter와 스케줄링 오버헤드는 측정 결과에 노이즈를 끼게 만드는 주요인.

스케줄러의 움직임을 확인하는 가장 쉬운 방법은 OS가 스케줄링 과정에서 발생시킨 오버헤드를 관측

```java
public class SchedulingOverhead {

    public static void main(String[] args) throws InterruptedException {
        long start = System.currentTimeMillis();
        for (int i = 0; i < 1_000; i++) {
            Thread.sleep(1);
        }
        long end = System.currentTimeMillis();
        System.out.println("Millis elapsed: " + (end - start));
    }
}
```

실행 결과

```bash
Millis elapsed: 1622
```

### 시간 문제

POSIX(portable operating system interface) 같은 업계 표준이 있어도 OS는 저마다 다르게 작동함

예로 os::javaTimeMillis()는 호스트 OS가 제공하는 기능에 의존하는 함수

BSD 유닉스 예

```cpp
jlong os::javaTimeMillis() {
  timeval time;
  int status gettimeofday(&time, NULL);
  assert(status != -1, "bsd error");
  return jlong(time.tv_sec) * 1000 + jlong(time.tv_usec / 1000);
}
```

윈도우

```cpp
jlong os::javaTimeMillis() {
  if (UseFakeTimers) {
    return fake_time++;
  } else {
    FiLETIME wt;
    GetSystemTimeAsFileTime(&wt);
    return windows_to_java_time(wt);
  }
}
```

윈도우는 유닉스 timeval 구조체 대신 64비트 FiLETIME 구조체를 이용, 1601년 이후 경과한 시간을 100나노초 단위로 기록. 윈도우는 물리 타이밍 하드웨어에 따라 달라지는 시스템 클록의 실 정확도real accuracy라는 개념이 있어 자바에서 타이밍 콜을 해도 그 작동 방식은 윈도우가 위치한 머신에 따라 달라짐.

### 컨텍스트 스위칭

컨텍스트 스위칭은 비싼 작업 유저 스레드가 타임 슬라이스(선취preemption, OS가 멀티태스킹을 구현하기 위해 프로세스 동의 없이 임의로 인터럽트를 걸고 나중에 다시 프로세스를 재개 하는 것) 도중 커널 모드로 바꾸어 어떤 기능을 실행해야 할 때가 있음.
하지만 유저 공간에 있는 코드가 액세스하는 메모리 여역은 커널 코드와 거의 공유할 부분이 없기 때문에 모드가 바뀌면 명령어와 다른 캐시를 어쩔 수 없이 강제로 비워야 함

커널 모드로 컨텍스트 스위칭 시 TLB를 비롯한 다른 캐시까지도 무효화됨. 이 캐시들은 시스템 콜 반환 시 다시 채워야 함으로 유저 공간으로 다시 제어권이 넘어간 후에도 당분간 이어짐

-> 시스템 콜의 진짜 비용이 가려지게 됨

리눅스에서는 이를 최대한 만회하기 위해 가상 동적 공유 객체virtual Dynamically Shared Object(vDSO)라는 장치를 제공. vDSO는 굳이 커널 프리빌리지kernel privileges가 필요 없는 시스템 콜의 속도를 높이려고 쓰는 유저 공간의 메모리 영역.

## 단순 시스템 모델

단순 시스템 모델의 근본은 유닉스 계열 OS에서 작동하는 자바 애플리케이션의 단순한 개념. 이들 중 누구다로 성능 문제를 유발할 수 있음

- 애플리케이션이 실행되는 하드웨어와 OS
- 애플리케이션이 실행되는 JVM/컨테이너
- 애플리케이션 코드 자체
- 애플리케이션이 호출하는 외부 시스템
- 애플리케이션으로 유입되는 트래픽

## 기본 감지 전략

### CPU 사용률

튜닝이 잘 된 프로그램은 리소스를 최대한 활용. 계산을 많이 하는 워크로드는 유저 공간의 CPU 사용률을 100%에 가깝게 유지하는 것이 목표

유저 공간에서 CPU 사용률이 100% 근처도 못 갔는데 어떤 프로세스에서 컨텍스트 교환 비율이 높게 나타나면 I/O에서 블로킹이 일어났거나, 스레드 락 경합thread lock contention 상황이 벌어졌을 확률이 높다.

### 가비지 수집

일반적인(핫스팟) JVM은 시작 시 메모리를 유저 공간에 할당 및 관리. 따라서 메모리 할당을 위해 sbrk() 와 같은 시스템 콜이 필요가 없음.

-> 가비지 수집을 위해 커널 교환을 할 일이 거의 없음

따라서 어떤 시스템에서 CPU 사용률이 아주 높게 나타날 때 GC가 주범이 되지는 않음. 반대로 어떤 JVM 프로세스가 유저 공간에서 CPU를 100%에 가깝게 사용하고 있다면 GC를 의심해야 함.

### 입출력

자바 프로그램은 대부분 단순한 I/O만 처리

#### 커널 바이패스 I/O

커널을 이용해 데이터를 복사해 유저 공간에 넣는 작업이 상당히 비싼 고성느 애플리케이션일 경우 커널 대신 직접 네트워크 카드에서 유저가 접근 가능한 영역으로 데이터를 매핑하는 전용 하드웨어/소프트웨어를 사용

이렇게 하면 커널 공간과 유저 공간 사이를 넘나드는 행위 및 이중 복사를 막을 수 있음

자바는 기본적으로 이와 관련된 구현체를 제공하지 않으므로 필요한 기능을 구현하려면 커스텀 라이브러리를 사용해야 함

## JVM과 운영체제

JVM은 자바 코드에 공용 인터페이스를 제공하여 OS에 독립적인 휴대용 실행 환경을 제공

하지만 스레드 스케줄링 같은 아주 기본적인 서비스조차도 하부 OS에 반드시 액세스해야 함

예를 들어 java.lang.Object 클래스에는 다음과 같이 논프라이빗non-private 네이티브 메서드가 선언되어 있음

```java
public final native Class<?> getClass();
public native int hashCode();
protected native Object clone() throws CloneNotSupportedException;
public final native void notify();
public final native void notifyAll();
public final native void wait(long timeout) throws InterruptedException;
```

이들 메소드는 비교적 저수준의 플랫폼 관심사를 처리

os::javaTimeMillis() 함수는 자바 정적 메소드 System.currentTimeMillis()에 구현된 로직을 처리

실제 코드는 C++로 작성됐지만 자바에서 C 코드 브릿지bridge를 통해 액세스 할 수 있음

핫스팟 JVM에서 네이티브 메소드 System.currentTimeMillis()는 JVM_CurrentTimeMillis()라는 JVM 엔트리 포인트 메소드에 매핑된다.

.java/lang/System.c 파일에 포함된 JNI Java_java_lang_System_registerNatives()에 이러한 매핑 관계가 설정돼있음

```cpp
static JNINativeMethod methods[] = {
  {"currentTimeMillis", "()J",    (void *)&JVM_CurrentTimeMillis},
  {"nanoTime",          "()J",    (void *)&JVM_NanoTime},
  {"arraycopy",         "(" OBJ "I" OBJ "II)V", (void *)&JVM_ArrayCopy},

  #undef OBJ

  JNIEXPORT void JNICALL
  Java_java_lang_System_registerNatives(JNIEnv *env, jclass cls) {
    (*env)->RegisterNatives(env, cls, methods, sizeof(methods)/sizeof(methods[0]));
  }
}
```

JVM_CurrentTimeMillis()는 VM 진입점에 해당하는 메소드를 호출. 모양은 C함수지만 본 모습은 C 호출 관례에 따라 익스포트된 C++ 함수. 결국 OpenJDK 매크로 2개로 감싼 os::javaTimeMillis()를 호출하는 구조

이 메소드는 os namespace에 정의되어 있고 OS에 의존.
- http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/os/linux/vm/os_linux.cpp
- http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/os/windows/vm/os_windows.cpp
